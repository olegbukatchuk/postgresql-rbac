# Разворачивание микрокластера PostgreSQL-patroni-nomad/compose

### В Docker-compose
Для разворачивания микрокластера в docker-compose можно воспользоваться соответствующим файлом.
**Compose** разворачивает микрокластер **Consul'a** и микрокластер **PostgreSQL** в докере.
Для запуска **Compose** файла необходимо либо собрать контейнер используя **Dockerfile**, либо использовать **Docker-registry** (docker-infra.cian.ru/sa-pgsql)

### В Nomad
Для запуска кластера в **Nomad** используем **pgsql-patroni.nomad**. Можно запустить из GUI или из bash. Для запуска задачи требуется наличие
**Consul'a**
 
Для запуска должны быть определены следующие переменные:

```datacenters```
Название кластера nomad.

```PATRONI_NAME = "pgsql-${NOMAD_ALLOC_INDEX}"```
**Nomad** именует запускаемые контейнеры используя ```Alloc_ID```, поэтому что бы наши контейнеры могли зарегестрироваться в Consul и имели читаемые имена,используем ```NOMAD_ALLOC_INDEX```. Этот индекс присваивается контейнеру при запуске, от 0 с шагом 1.

```PATRONI_POSTGRESQL_CONNECT_ADDRESS = "${NOMAD_ADDR_pgsql}"```
Для регестрации connection-string **PostgreSQL**  в **Consul** используется ```NOMAD_ADDR_pgsql```.
Этот параметр принимает значение IP адреса сервера, на котором запускается контейнер и Port, через который прокидывается соединение в контейнер на порт определенный в ```port_map```.

```PATRONI_CONSUL_HOST```
Так как Patroni должен зарегестрироваться в Consul мы используем агента, который находится на хостовом сервере.

Для hardlimit'ов мы используем  
```
    resources {
        cpu = 4400      #MHz
        memory = 512    #Mb
        disk = 1024     #Mb
        network {
          mbits = 100
          port "patroni" {}
          port "pgsql" {}
        }
      }
```
# Разворачивание нескольких кластеров pgsql в Nomad

### 1.Сначала собирваем контейнер с postgres-patroni.
Для того что бы оба кластера зарегестрировались в консул под разными именами необходимо передать ENV ```(PATRONI_SCOPE = "${NOMAD_JOB_NAME}")```
 Разворачиваем 2 задачи в номаде pgsql-msrvc01/02.nomad. Они создадут 2 разных кластера pgsql. Порты Patroni статичные и меняются в зависимости от кластера.

```
      resources {
        cpu = 4400
        memory = 512
        disk = 1024
        network {
          mbits = 100
          port "patroni" {
            static = "8008"
          }
          port "pgsql" {
          }
        }
      }
```

### 2.Разворачиваем haproxy
Для каждого кластера pgsql создается свой набор контейнеров HAProxy. Кол-во контейнеров должно ровняться кол-ву железных хостов.
Собрираем контейнер. После этого запускаем задачу в nomad. HAProxy использует статичный порт для прослушивания соединений.
В конфиге HAProxy описан резолвер в виде Consul'a.
На каждый хост кластера мы ставим corosync/pacemaker и создаем VirtualIP, к нему будут обращаться клиенты при запросе базы с индивидумальным портом.


# Backup кластера pgsql

Backup выполняется с помощью pgbackrest. Создаются задачи описанные в **cron_backup**. В дир-рию /root/ кладется файл **pgsql_backup.sh**.
**pgsql_backup.sh** выполняет поиск контейнера на хосте с образом pgsql и запускает backup через ```docker exec```.
Бэкап будет выполняться на всех серверах, но удачно выполнится только на сервере с master контейнером.

Архивация wal файлов происходит автоматически самим postgresql (```archive_command```). При запуске контейнера в фоне выполняется скрипт
**stanza_init.sh**, который ожидает запуска сервиса postgresql, после чего инициирует репозиторий stanza.
Это выполняется так же на всех контейнерах, но успешным выполнение будет только на master.